В вычислениях может принимать участие специальный мастер-процесс на питоне
либо работа идет без него.

Без питон-мастера все общение идет через mpi_comm_world,
иначе работники объединяются в отдельный коммуникатор comp

Управление временем на совести comp-0 в любом случае


Порядок работы
                1. WORLD+COMP                          2. WORLD ONLY
1. WORLD Bcast user-status, источник - world-0    |    +
             xx.  идет расчет шага, используется только COMP
2. WORLD Allreduce compute-status                 |    +
             xx.  идет расчет ошибки, используется только COMP
5. accept/reject, comp-0 -> world-0               |    -
6. new timestep, comp-0 -> world-0                |    -
7. ready to collect data, comp-0 -> world-0       |    -
8. WORLD collect data                             |    +






Решение идет так


Domain::compute
    
    стадия -1 для методов с FSAL
    подготовить данные (пересылки границ)
    вычислить функцию
    подготовить аргумент для следующего вычисления функции
    
    цикл по шагам
        цикл по стадиям
            подготовить данные (пересылки границ)
            вычислить функцию
            подготовить аргумент для следующего вычисления функции
        
        для переменного шага проверить ошибку
            при недопустимой ошибке начать шаг заново с меньшей величиной шага
        
        для постоянного шага или при допустимой ошибке сделать шаг 
            проваливаемся через классы до Solver::confirmStep
        
        для переменного шага 
        вычисляем новую величину шага Solver::getNewStep
    
 
 Пример: Дорман-Принс 4(5)
     стадия -1 (подготовка к циклу)
     k1 = f(y_n)             | block->computeStage*(-1)
     arg = y_n+h*a21*k1        | solver->prepareArgument(-1)
  
  цикл по шагам
     стадия 0.
     k2 = f(arg)   
     arg = y_n+h(a31*k1+a32*k2)
     
     стадия 1.
     k3 = f(arg)   
     arg = y_n+h(a41*k1+a42*k2+a43*k3)
     
     стадия 2.
     k4 = f(arg)   
     arg = y_n+h(a51*k1+a52*k2+a53*k3+a54*k4)
     
     стадия 3.
     k5 = f(arg)   
     arg = y_n+h(a61*k1+a62*k2+a63*k3+a64*k4+a65*k5)
     
     стадия 4.
     k6 = f(arg)   
     arg = y_n+h(a71*k1+a72*k2+a73*k3+a74*k4+a75*k5+a76*k6)
     
     стадия 5.
     k7 = f(arg)            | block->computeStage*(5)
     нечего подготавливать  | solver->prepareArgument(5)
     
     если шаг подтвержден:
     y_n<->arg              |solver->confirmStep
         arg = y_n+h*a21*k1       |solver->prepareFSAL
     
     